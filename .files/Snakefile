'''Snakefile for MIS post-imputation QC
   Version 0.1.1'''

from scripts.parse_config import parser
from getpass import getuser

import os
import socket

isMinerva = "hpc.mssm.edu" in socket.getfqdn()
RWD = os.getcwd()

configfile: "./config.yaml"
shell.executable("/bin/bash")

if isMinerva:
    shell.prefix("PATH=" + config["anaconda"] + ":$PATH; ")
    tempdir = "/sc/orga/scratch/{}/temp/".format(getuser())
    com = {'plink': 'plink --keep-allele-order', 'plink2': 'plink2',
           'bcftools': 'bcftools', 'R': 'Rscript', 'R2': 'R',
           'cat-bgen': 'cat-bgen', 'qctool': 'qctool'}
    loads = {'plink': 'module load plink/1.90',
             'plink2': 'module load plink2/dev.2oct',
             'bcftools': 'module load bcftools/1.7',
             'R': ('module load R/3.4.3 pandoc/2.1.3 udunits/2.2.26; ',
                   'RSTUDIO_PANDOC=$(which pandoc)'),
             'qctool': 'module load qctool/v2', 'cat-bgen': 'module load bgen'}
else:
    com = {'plink': 'plink --keep-allele-order', 'plink2': 'plink2',
           'bcftools': 'bcftools', 'R': 'Rscript', 'R2': 'R',
           'cat-bgen': 'cat-bgen', 'qctool': 'qctool'}
    loads = {'plink': 'echo running plink', 'plink2': 'echo running plink',
             'cat-bgen': 'echo using bgen lib',
             'bcftools': 'echo running bcftools',  'R': 'echo running R',
             'qctool': 'echo running qctool'}
    tempdir = "/tmp/{}/postImpute/".format(getuser())

BPLINK = ["bed", "bim", "fam"]

CHROM, SAMPLE, INPATH, KEEP_COMMAND = parser(config)

def flatten(nested):
    flat = []
    for el in nested:
        if not isinstance(el, list):
            flat.append(el)
        else:
            flat += flatten(el)
    return flat


# Change filtering based on presence of rsq2
qualfilt = "(R2 >= {R2} && MAF >= {MAF})".format(
    R2=config["qc"]["rsq"], MAF=config["qc"]["maf"])
if config["qc"]["rsq2"] and config["qc"]["rsq2"] != 'NA':
    qualfilt += " || (R2 >= {R2} && MAF < {MAF})".format(
        R2=config["qc"]["rsq2"], MAF=config["qc"]["maf"])

# remove subjects if sample filtering file is provided
sampfilt = ""
if config["exclude_samp"] or config["include_samp"]:
    sampfilt += com["bcftools"] + " view --samples-file "
    if config["exclude_samp"]:
        sampfilt += "^{}".format(config["exclude_samp"])
    if config["include_samp"]:
        sampfilt += "{}".format(config["include_samp"])

plink_bycohort = "data/{sample}_chrall_filtered.{ext}"
plink_merged = "data/all_chrall_filtered.{ext}"

outs = dict(
    stat_report=expand("stats/{sample}_impStats.html", sample=SAMPLE),
    vcf_bycohort=expand("data/{sample}_chrall_filtered.vcf.gz", sample=SAMPLE),
    vcf_merged="data/all_chrall_filtered.vcf.gz",
    bgen_bycohort=expand("data/{sample}_chrall_filtered.bgen", sample=SAMPLE),
    bgen_merged="data/merged/merged_chrall_filtered.bgen",
    plink_bycohort=expand(plink_bycohort, sample=SAMPLE, ext=BPLINK),
    plink_merged=expand(plink_merged, ext=BPLINK)
            )

outputs = [outs[x] for x in config["outputs"]]
outputs = flatten(outputs)

rule all:
    input: outputs

rule stats:
    input: "scripts/Post_imputation.Rmd"
    output: "stats/{sample}_impStats.html"
    params:
        path = INPATH + "{sample}/",
        chrom = config["chroms"],
        cohort = "{sample}",
        maf = config["qc"]["maf"],
        rsq = config["qc"]["rsq"],
        rsq2 = config["qc"]["rsq2"],
        sampsize = config["qc"]["sampsize"],
        out = "{sample}_impStats.html",
        output_dir = "stats"
    shell:
        """
{loads[R]}
{com[R2]} -e 'rmarkdown::render(\
  "{input}", output_file = "{params.out}", \
  output_dir = "{params.output_dir}", params = list(\
  path = "{params.path}", outpath = "{params.output_dir}", \
  cohort = "{params.cohort}", chrom = "{params.chrom}", \
  maf = {params.maf}, rsq = {params.rsq}, rsq2 = {params.rsq2}))' --slave
        """

# Sample filtering rules

file_in = INPATH + "{sample}/chr{chrom}.dose.vcf.gz"

rule fixheaders:
    input:
        vcf = INPATH + "{sample}/chr{chrom}.dose.vcf.gz",
        tbi = INPATH + "{sample}/chr{chrom}.dose.vcf.gz.tbi",
    output:
        vcf = temp(tempdir + "fixedheader/{sample}/chr{chrom}.dose.vcf.gz"),
        tbi = temp(tempdir + "fixedheader/{sample}/chr{chrom}.dose.vcf.gz.tbi"),
    threads: 1
    shell:
        r"""
if $(zcat {input} | head -n 40 | grep -q "##FILTER"); then
  cp {input.vcf} {output.vcf}
  cp {input.tbi} {output.tbi}
else
  {loads[bcftools]}
  zcat {input.vcf} | sed '/contig/ a\
##FILTER=<ID=GENOTYPED,Description="Marker was genotyped AND imputed">\
##FILTER=<ID=GENOTYPED_ONLY,Description="Marker was genotyped but NOT imputed">' | \
{com[bcftools]} view -Oz -o {output.vcf}
  {com[bcftools]} index -t {output.vcf}
fi
"""

filter_annotate = (com["bcftools"] + " annotate -i \"%FILTER='GENOTYPED' || "
                   "{params.filt}\" -Oz -o {output} "
                   "--set-id '%CHROM:%POS:%REF:%ALT' --threads 8")
filter_out = "data/by_chrom/{sample}_chr{chrom}_filtered.vcf.gz"

if sampfilt:
    rule filters:
        input:
            vcf = rules.fixheaders.output.vcf,
            tbi = rules.fixheaders.output.tbi
        output: temp(filter_out)
        params:
            filt = qualfilt,
            sf = sampfilt
        threads: 8
        shell:
            "{loads[bcftools]}; "
            "{params.sf} --force-samples -Oz --threads 8 {input.vcf} | "
            "" + filter_annotate

else:
    rule filters:
        input:
            vcf = rules.fixheaders.output.vcf,
            tbi = rules.fixheaders.output.tbi
        output: temp(filter_out)
        params:
            filt = qualfilt,
            sf = sampfilt
        threads: 8
        shell: "{loads[bcftools]}; " + filter_annotate + " {input.vcf}"

# defaults for renaming:
renamed_cat = "data/by_chrom/{{sample}}_chr{chrom}_filtered.vcf.gz"
renamed = "data/by_chrom/{sample}_chr{chrom}_filtered.vcf.gz"
renamed_merge = "data/by_chrom/{sample}_chr{{chrom}}_filtered.vcf.gz"
automap_tf = False
rename_tf = False

#override defaults:
if 'rename' in config:
    if (config['rename'] is not None and
        'automap' in config['rename'] and
        config['rename']['automap']):
        print("Automatically renaming samples.")
        automap_tf = True
        automap = config['rename']['automap']
        renamed_cat = "data/by_chrom/{{sample}}_chr{chrom}_filtered_fixedIDs.vcf.gz"
        renamed = "data/by_chrom/{sample}_chr{chrom}_filtered_fixedIDs.vcf.gz"
        renamed_merge = "data/by_chrom/{sample}_chr{{chrom}}_filtered_fixedIDs.vcf.gz"
    elif config['rename'] and not type(config['rename']) is dict:
        print("Manualy renameing samples")
        renamefile = config['rename']
        renamed_cat = "data/by_chrom/{{sample}}_chr{chrom}_filtered_renamed.vcf.gz"
        renamed = "data/by_chrom/{sample}_chr{chrom}_filtered_renamed.vcf.gz"
        renamed_merge = "data/by_chrom/{sample}_chr{{chrom}}_filtered_renamed.vcf.gz"

rule rename:
    input:
        vcf = rules.filters.output,
        mapping = renamefile if rename_tf else "/dev/null"
    output: temp("data/by_chrom/{sample}_chr{chrom}_filtered_renamed.vcf.gz")
    shell:
        "{loads[bcftools]}; "
        "{com[bcftools]} reheader --samples {input.mapping} -o {output} -Oz {input.vcf}"

rule renameAuto:
    input:
        vcf = rules.filters.output,
        mapping = automap if automap_tf else "/dev/null"
    output:
        fixed = temp("data/by_chrom/{sample}_chr{chrom}_filtered_fixedIDs.vcf.gz"),
        mapping = "data/by_chrom/{sample}_chr{chrom}_vcfmap.tsv",
        reheader = temp("data/by_chrom/{sample}_chr{chrom}_vcfreheader.txt")
    shell:
        "{loads[bcftools]}; {loads[R]}; "
        "{com[R]} scripts/fix_HRCvcf.R {input.vcf} {input.mapping} {output.mapping} {output.reheader}; "
        "{com[bcftools]} reheader --samples {output.reheader} {input.vcf} | "
        "{com[bcftools]} view -o {output.fixed} -Oz"

rule concat_chroms_samp:
    input: expand(renamed_cat, chrom=CHROM)
    output: "data/{sample}_chrall_filtered.vcf.gz"
    threads: 8
    shell:
        "{loads[bcftools]}; "
        "{com[bcftools]} concat -o {output} -Oz --threads 8 {input}"

rule index_samples_chrom:
    input: renamed
    output: renamed + ".tbi"
    shell:
        "{loads[bcftools]}; "
        "{com[bcftools]} index -t {input}"

rule merge_samples_chrom:
    input:
        vcf = expand(renamed_merge, sample=SAMPLE),
        tbi = expand(renamed_merge + ".tbi", sample=SAMPLE)
    output: "data/by_chrom/all_chr{chrom}_filtered.vcf.gz"
    threads: 8
    shell:
        "{loads[bcftools]}; "
        "{com[bcftools]} merge -m none -o {output} -Oz --threads 8 {input.vcf}"

rule concat_chroms_all:
    input: expand("data/by_chrom/all_chr{chrom}_filtered.vcf.gz", chrom=CHROM)
    output: "data/all_chrall_filtered.vcf.gz"
    threads: 8
    shell:
        "{loads[bcftools]}; "
        "{com[bcftools]} concat -o {output} -Oz --threads 8 {input}"

rule make_plink_all:
    input: rules.concat_chroms_all.output
    output: expand("data/all_chrall_filtered.{ext}", ext=BPLINK)
    params:
        out_plink = "data/all_chrall_filtered",
        ID = "--id-delim" if automap_tf else "--double-id"
    threads: 10
    shell:
        "{loads[plink2]}; "
        "{com[plink2]} --vcf {input} {params.ID} --memory 10000 --threads 10 --make-bed "
        "--out {params.out_plink}"

rule make_plink_samp:
    input: rules.concat_chroms_samp.output
    output: expand("data/{{sample}}_chrall_filtered.{ext}", ext=BPLINK)
    params:
        out_plink = "data/{sample}_chrall_filtered",
        ID = "--id-delim" if automap_tf else "--double-id "
    threads: 10
    shell:
        "{loads[plink2]}; "
        "{com[plink2]} --vcf {input} {params.ID} --memory 10000 --threads 10 --make-bed "
        "--out {params.out_plink}"

rule make_bgen:
    input:
        gen = renamed
    output:
        bgen = temp(tempdir + "{sample}_chr{chrom}_filtered.bgen"),
        samp = temp(tempdir + "{sample}_chr{chrom}.sample")
    shell:
        """
{loads[qctool]}
{com[qctool]} -g {input.gen} -vcf-genotype-field GP \
-os {output.samp} -og {output.bgen}
"""

rule cat_bgen_samp:
    input:
        gen = expand(tempdir + "{{sample}}_chr{chrom}_filtered.bgen", chrom=CHROM),
        samp = expand(tempdir + "{{sample}}_chr{chrom}.sample", chrom=CHROM)[0]
    output:
        gen = "data/{sample}_chrall_filtered.bgen",
        samp = "data/{sample}_chrall.sample"
    shell:
        """
{loads[cat-bgen]}
{com[cat-bgen]} -g {input.gen} -og {output.gen}
cp {input.samp} {output.samp}"""

bga_gen = expand(tempdir + "{sample}_chr{{chrom}}_filtered.bgen", sample=SAMPLE)
bga_samp = expand(tempdir + "{sample}_chr{{chrom}}.sample", sample=SAMPLE)

rule make_bgen_allsamp:
    input:
        gen = bga_gen,
        samp = bga_samp
    output:
        bgen = "data/merged/merged_chr{chrom}_filtered.bgen",
        samp = "data/merged/merged_chr{chrom}.sample"
    params:
        args = " ".join(["-g {} -s {}".format(gen, samp) for gen, samp in zip(bga_gen, bga_samp)])
    threads: 10
    shell:
        """
module load qctool/v2
qctool {params.args} -og {output.bgen} -os {output.samp} -threads 10
"""

rule cat_bgen_allsamp:
    input:
        gen = expand("data/merged/merged_chr{chrom}_filtered.bgen", chrom=CHROM),
        samp = expand("data/merged/merged_chr{chrom}.sample", chrom=CHROM)[0]
    output:
        gen = "data/merged/merged_chrall_filtered.bgen",
        samp = "data/merged/merged_chrall.sample"
    shell:
        """
{loads[cat-bgen]}
{com[cat-bgen]} -g {input.gen} -og {output.gen}
cp {input.samp} {output.samp}"""
